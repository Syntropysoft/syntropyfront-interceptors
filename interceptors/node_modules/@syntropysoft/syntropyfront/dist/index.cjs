'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * BreadcrumbStore - Almacén de huellas del usuario
 * Mantiene un historial de las últimas acciones del usuario
 */
class BreadcrumbStore {
    constructor(maxBreadcrumbs = 25) {
        this.maxBreadcrumbs = maxBreadcrumbs;
        this.breadcrumbs = [];
        this.agent = null;
    }

    /**
     * Configura el agent para envío automático
     * @param {Object} agent - Instancia del agent
     */
    setAgent(agent) {
        this.agent = agent;
    }

    /**
     * Configura el tamaño máximo de breadcrumbs
     * @param {number} maxBreadcrumbs - Nuevo tamaño máximo
     */
    setMaxBreadcrumbs(maxBreadcrumbs) {
        this.maxBreadcrumbs = maxBreadcrumbs;
        
        // Si el nuevo tamaño es menor, eliminar breadcrumbs excedentes
        if (this.breadcrumbs.length > this.maxBreadcrumbs) {
            this.breadcrumbs = this.breadcrumbs.slice(-this.maxBreadcrumbs);
        }
    }

    /**
     * Obtiene el tamaño máximo actual
     * @returns {number} Tamaño máximo de breadcrumbs
     */
    getMaxBreadcrumbs() {
        return this.maxBreadcrumbs;
    }

    /**
     * Añade un breadcrumb a la lista
     * @param {Object} crumb - El breadcrumb a añadir
     * @param {string} crumb.category - Categoría del evento (ui, network, error, etc.)
     * @param {string} crumb.message - Mensaje descriptivo
     * @param {Object} [crumb.data] - Datos adicionales opcionales
     */
    add(crumb) {
        const breadcrumb = {
            ...crumb,
            timestamp: new Date().toISOString(),
        };

        if (this.breadcrumbs.length >= this.maxBreadcrumbs) {
            this.breadcrumbs.shift(); // Elimina el más antiguo
        }
        
        this.breadcrumbs.push(breadcrumb);
        
        // Callback opcional para logging
        if (this.onBreadcrumbAdded) {
            this.onBreadcrumbAdded(breadcrumb);
        }
        
        // Enviar al agent si está configurado
        if (this.agent) {
            this.agent.sendBreadcrumbs([breadcrumb]);
        }
    }

    /**
     * Devuelve todos los breadcrumbs
     * @returns {Array} Copia de todos los breadcrumbs
     */
    getAll() {
        return [...this.breadcrumbs];
    }

    /**
     * Limpia todos los breadcrumbs
     */
    clear() {
        this.breadcrumbs = [];
    }

    /**
     * Obtiene breadcrumbs por categoría
     * @param {string} category - Categoría a filtrar
     * @returns {Array} Breadcrumbs de la categoría especificada
     */
    getByCategory(category) {
        return this.breadcrumbs.filter(b => b.category === category);
    }
}

// Instancia singleton
const breadcrumbStore = new BreadcrumbStore();

/**
 * RobustSerializer - Serializador robusto que maneja referencias circulares
 * Implementa una solución similar a flatted pero sin dependencias externas
 */
class RobustSerializer {
    constructor() {
        this.seen = new WeakSet();
        this.circularRefs = new Map();
        this.refCounter = 0;
    }

    /**
     * Serializa un objeto de forma segura, manejando referencias circulares
     * @param {any} obj - Objeto a serializar
     * @returns {string} JSON string seguro
     */
    serialize(obj) {
        try {
            // Reset state
            this.seen = new WeakSet();
            this.circularRefs = new Map();
            this.refCounter = 0;

            // Serializar con manejo de referencias circulares
            const safeObj = this.makeSerializable(obj);
            
            // Convertir a JSON
            return JSON.stringify(safeObj);
        } catch (error) {
            console.error('SyntropyFront: Error en serialización robusta:', error);
            
            // Fallback: intentar serialización básica con información de error
            return JSON.stringify({
                __serializationError: true,
                error: error.message,
                originalType: typeof obj,
                isObject: obj !== null && typeof obj === 'object',
                timestamp: new Date().toISOString()
            });
        }
    }

    /**
     * Hace un objeto serializable, manejando referencias circulares
     * @param {any} obj - Objeto a procesar
     * @param {string} path - Ruta actual en el objeto
     * @returns {any} Objeto serializable
     */
    makeSerializable(obj, path = '') {
        // Casos primitivos
        if (obj === null || obj === undefined) {
            return obj;
        }

        if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {
            return obj;
        }

        // Casos especiales
        if (obj instanceof Date) {
            return {
                __type: 'Date',
                value: obj.toISOString()
            };
        }

        if (obj instanceof Error) {
            return {
                __type: 'Error',
                name: obj.name,
                message: obj.message,
                stack: obj.stack,
                cause: obj.cause ? this.makeSerializable(obj.cause, `${path}.cause`) : undefined
            };
        }

        if (obj instanceof RegExp) {
            return {
                __type: 'RegExp',
                source: obj.source,
                flags: obj.flags
            };
        }

        // Arrays
        if (Array.isArray(obj)) {
            // Verificar referencia circular
            if (this.seen.has(obj)) {
                const refId = this.circularRefs.get(obj);
                return {
                    __circular: true,
                    refId: refId
                };
            }

            this.seen.add(obj);
            const refId = `ref_${++this.refCounter}`;
            this.circularRefs.set(obj, refId);

            return obj.map((item, index) => 
                this.makeSerializable(item, `${path}[${index}]`)
            );
        }

        // Objetos
        if (typeof obj === 'object') {
            // Verificar referencia circular
            if (this.seen.has(obj)) {
                const refId = this.circularRefs.get(obj);
                return {
                    __circular: true,
                    refId: refId
                };
            }

            this.seen.add(obj);
            const refId = `ref_${++this.refCounter}`;
            this.circularRefs.set(obj, refId);

            const result = {};

            // Procesar propiedades del objeto
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    try {
                        const value = obj[key];
                        const safeValue = this.makeSerializable(value, `${path}.${key}`);
                        result[key] = safeValue;
                    } catch (error) {
                        // Si falla la serialización de una propiedad, la omitimos
                        result[key] = {
                            __serializationError: true,
                            error: error.message,
                            propertyName: key
                        };
                    }
                }
            }

            // Procesar símbolos si están disponibles
            if (Object.getOwnPropertySymbols) {
                const symbols = Object.getOwnPropertySymbols(obj);
                for (const symbol of symbols) {
                    try {
                        const value = obj[symbol];
                        const safeValue = this.makeSerializable(value, `${path}[Symbol(${symbol.description})]`);
                        result[`__symbol_${symbol.description || 'anonymous'}`] = safeValue;
                    } catch (error) {
                        result[`__symbol_${symbol.description || 'anonymous'}`] = {
                            __serializationError: true,
                            error: error.message,
                            symbolName: symbol.description || 'anonymous'
                        };
                    }
                }
            }

            return result;
        }

        // Funciones y otros tipos
        if (typeof obj === 'function') {
            return {
                __type: 'Function',
                name: obj.name || 'anonymous',
                length: obj.length,
                toString: obj.toString().substring(0, 200) + '...'
            };
        }

        // Fallback para otros tipos
        return {
            __type: 'Unknown',
            constructor: obj.constructor ? obj.constructor.name : 'Unknown',
            toString: String(obj).substring(0, 200) + '...'
        };
    }

    /**
     * Deserializa un objeto serializado con referencias circulares
     * @param {string} jsonString - JSON string a deserializar
     * @returns {any} Objeto deserializado
     */
    deserialize(jsonString) {
        try {
            const parsed = JSON.parse(jsonString);
            return this.restoreCircularRefs(parsed);
        } catch (error) {
            console.error('SyntropyFront: Error en deserialización:', error);
            return null;
        }
    }

    /**
     * Restaura referencias circulares en un objeto deserializado
     * @param {any} obj - Objeto a restaurar
     * @param {Map} refs - Mapa de referencias
     * @returns {any} Objeto con referencias restauradas
     */
    restoreCircularRefs(obj, refs = new Map()) {
        if (obj === null || obj === undefined) {
            return obj;
        }

        if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {
            return obj;
        }

        // Restaurar tipos especiales
        if (obj.__type === 'Date') {
            return new Date(obj.value);
        }

        if (obj.__type === 'Error') {
            const error = new Error(obj.message);
            error.name = obj.name;
            error.stack = obj.stack;
            if (obj.cause) {
                error.cause = this.restoreCircularRefs(obj.cause, refs);
            }
            return error;
        }

        if (obj.__type === 'RegExp') {
            return new RegExp(obj.source, obj.flags);
        }

        if (obj.__type === 'Function') {
            // No podemos restaurar funciones completamente, devolvemos info
            return `[Function: ${obj.name}]`;
        }

        // Arrays
        if (Array.isArray(obj)) {
            const result = [];
            refs.set(obj, result);

            for (let i = 0; i < obj.length; i++) {
                if (obj[i] && obj[i].__circular) {
                    const refId = obj[i].refId;
                    if (refs.has(refId)) {
                        result[i] = refs.get(refId);
                    } else {
                        result[i] = null; // Referencia no encontrada
                    }
                } else {
                    result[i] = this.restoreCircularRefs(obj[i], refs);
                }
            }

            return result;
        }

        // Objetos
        if (typeof obj === 'object') {
            const result = {};
            refs.set(obj, result);

            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    if (key.startsWith('__')) {
                        // Propiedades especiales
                        continue;
                    }

                    const value = obj[key];
                    if (value && value.__circular) {
                        const refId = value.refId;
                        if (refs.has(refId)) {
                            result[key] = refs.get(refId);
                        } else {
                            result[key] = null; // Referencia no encontrada
                        }
                    } else {
                        result[key] = this.restoreCircularRefs(value, refs);
                    }
                }
            }

            return result;
        }

        return obj;
    }

    /**
     * Serializa de forma segura para logging (versión simplificada)
     * @param {any} obj - Objeto a serializar
     * @returns {string} JSON string seguro para logs
     */
    serializeForLogging(obj) {
        try {
            return this.serialize(obj);
        } catch (error) {
            return JSON.stringify({
                __logError: true,
                message: 'Error serializando para logging',
                originalError: error.message,
                timestamp: new Date().toISOString()
            });
        }
    }
}

// Instancia singleton
const robustSerializer = new RobustSerializer();

/**
 * Agent - Envía datos de trazabilidad al backend
 * Implementa reintentos con backoff exponencial y buffer persistente
 */
class Agent {
    constructor() {
        this.endpoint = null;
        this.headers = {
            'Content-Type': 'application/json'
        };
        this.batchSize = 10;
        this.batchTimeout = null; // Por defecto = solo errores
        this.queue = [];
        this.batchTimer = null;
        this.isEnabled = false;
        this.sendBreadcrumbs = false; // Por defecto = solo errores
        this.encrypt = null; // Callback de encriptación opcional
        
        // Sistema de reintentos
        this.retryQueue = []; // Cola de reintentos
        this.retryTimer = null;
        this.maxRetries = 5;
        this.baseDelay = 1000; // 1 segundo
        this.maxDelay = 30000; // 30 segundos
        
        // Buffer persistente
        this.usePersistentBuffer = false;
        this.dbName = 'SyntropyFrontBuffer';
        this.dbVersion = 1;
        this.storeName = 'failedItems';
        
        // Inicializar buffer persistente si está disponible
        this.initPersistentBuffer();
    }

    /**
     * Inicializa el buffer persistente (IndexedDB)
     */
    async initPersistentBuffer() {
        try {
            if (!window.indexedDB) {
                console.warn('SyntropyFront: IndexedDB no disponible, usando solo memoria');
                return;
            }

            const request = indexedDB.open(this.dbName, this.dbVersion);
            
            request.onerror = () => {
                console.warn('SyntropyFront: Error abriendo IndexedDB, usando solo memoria');
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(this.storeName)) {
                    db.createObjectStore(this.storeName, { keyPath: 'id', autoIncrement: true });
                }
            };

            request.onsuccess = () => {
                this.db = request.result;
                this.usePersistentBuffer = true;
                console.log('SyntropyFront: Buffer persistente inicializado');
                
                // Intentar enviar items fallidos al inicializar
                this.retryFailedItems();
            };
        } catch (error) {
            console.warn('SyntropyFront: Error inicializando buffer persistente:', error);
        }
    }

    /**
     * Guarda items fallidos en el buffer persistente
     */
    async saveToPersistentBuffer(items) {
        if (!this.usePersistentBuffer || !this.db) return;

        try {
            const transaction = this.db.transaction([this.storeName], 'readwrite');
            const store = transaction.objectStore(this.storeName);
            
            // ✅ SERIALIZACIÓN ROBUSTA: Serializar items antes de guardar
            let serializedItems;
            try {
                serializedItems = robustSerializer.serialize(items);
            } catch (error) {
                console.error('SyntropyFront: Error serializando items para buffer:', error);
                serializedItems = JSON.stringify({
                    __serializationError: true,
                    error: error.message,
                    timestamp: new Date().toISOString(),
                    fallbackData: 'Items no serializables'
                });
            }
            
            const item = {
                items: serializedItems, // Guardar como string serializado
                timestamp: new Date().toISOString(),
                retryCount: 0
            };
            
            await store.add(item);
            console.log('SyntropyFront: Items guardados en buffer persistente');
        } catch (error) {
            console.error('SyntropyFront: Error guardando en buffer persistente:', error);
        }
    }

    /**
     * Obtiene items fallidos del buffer persistente
     */
    async getFromPersistentBuffer() {
        if (!this.usePersistentBuffer || !this.db) return [];

        try {
            const transaction = this.db.transaction([this.storeName], 'readonly');
            const store = transaction.objectStore(this.storeName);
            const request = store.getAll();
            
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        } catch (error) {
            console.error('SyntropyFront: Error obteniendo del buffer persistente:', error);
            return [];
        }
    }

    /**
     * Remueve items del buffer persistente
     */
    async removeFromPersistentBuffer(id) {
        if (!this.usePersistentBuffer || !this.db) return;

        try {
            const transaction = this.db.transaction([this.storeName], 'readwrite');
            const store = transaction.objectStore(this.storeName);
            await store.delete(id);
        } catch (error) {
            console.error('SyntropyFront: Error removiendo del buffer persistente:', error);
        }
    }

    /**
     * Intenta enviar items fallidos del buffer persistente
     */
    async retryFailedItems() {
        if (!this.usePersistentBuffer) return;

        const failedItems = await this.getFromPersistentBuffer();
        
        for (const item of failedItems) {
            if (item.retryCount < this.maxRetries) {
                // ✅ DESERIALIZACIÓN ROBUSTA: Deserializar items del buffer
                let deserializedItems;
                try {
                    if (typeof item.items === 'string') {
                        deserializedItems = robustSerializer.deserialize(item.items);
                    } else {
                        deserializedItems = item.items; // Ya deserializado
                    }
                } catch (error) {
                    console.error('SyntropyFront: Error deserializando items del buffer:', error);
                    // Saltar este item y removerlo del buffer
                    await this.removeFromPersistentBuffer(item.id);
                    continue;
                }
                
                this.addToRetryQueue(deserializedItems, item.retryCount + 1, item.id);
            } else {
                console.warn('SyntropyFront: Item excedió máximo de reintentos, removiendo del buffer');
                await this.removeFromPersistentBuffer(item.id);
            }
        }
    }

    /**
     * Configura el agent
     * @param {Object} config - Configuración del agent
     * @param {string} config.endpoint - URL del endpoint para enviar datos
     * @param {Object} [config.headers] - Headers adicionales
     * @param {number} [config.batchSize] - Tamaño del batch
     * @param {number} [config.batchTimeout] - Timeout del batch en ms (si existe = modo completo)
     * @param {Function} [config.encrypt] - Callback para encriptar datos antes de enviar
     * @param {boolean} [config.usePersistentBuffer] - Usar buffer persistente (default: true)
     * @param {number} [config.maxRetries] - Máximo número de reintentos (default: 5)
     */
    configure(config) {
        this.endpoint = config.endpoint;
        this.headers = { ...this.headers, ...config.headers };
        this.batchSize = config.batchSize || this.batchSize;
        this.batchTimeout = config.batchTimeout; // Si existe = modo completo
        this.isEnabled = !!config.endpoint;
        this.encrypt = config.encrypt || null; // Callback de encriptación
        this.usePersistentBuffer = config.usePersistentBuffer !== false; // Por defecto: true
        this.maxRetries = config.maxRetries || this.maxRetries;
        
        // Lógica simple: si hay batchTimeout = enviar breadcrumbs, sino = solo errores
        this.sendBreadcrumbs = !!config.batchTimeout;
    }

    /**
     * Envía un error al backend
     * @param {Object} errorPayload - Payload del error
     * @param {Object} context - Contexto adicional (opcional)
     */
    sendError(errorPayload, context = null) {
        if (!this.isEnabled) {
            console.warn('SyntropyFront Agent: No configurado, error no enviado');
            return;
        }

        // Agregar contexto si está disponible
        const payloadWithContext = context ? {
            ...errorPayload,
            context: context
        } : errorPayload;

        // Aplicar encriptación si está configurada
        const dataToSend = this.encrypt ? this.encrypt(payloadWithContext) : payloadWithContext;

        this.addToQueue({
            type: 'error',
            data: dataToSend,
            timestamp: new Date().toISOString()
        });
    }

    /**
     * Envía breadcrumbs al backend
     * @param {Array} breadcrumbs - Lista de breadcrumbs
     */
    sendBreadcrumbs(breadcrumbs) {
        // Solo enviar breadcrumbs si está habilitado (batchTimeout configurado)
        if (!this.isEnabled || !this.sendBreadcrumbs || !breadcrumbs.length) {
            return;
        }

        // Aplicar encriptación si está configurada
        const dataToSend = this.encrypt ? this.encrypt(breadcrumbs) : breadcrumbs;

        this.addToQueue({
            type: 'breadcrumbs',
            data: dataToSend,
            timestamp: new Date().toISOString()
        });
    }

    /**
     * Añade un item a la cola de envío
     * @param {Object} item - Item a añadir
     */
    addToQueue(item) {
        this.queue.push(item);

        // Enviar inmediatamente si alcanza el tamaño del batch
        if (this.queue.length >= this.batchSize) {
            this.flush();
        } else if (this.batchTimeout && !this.batchTimer) {
            // Solo programar timeout si batchTimeout está configurado
            this.batchTimer = setTimeout(() => {
                this.flush();
            }, this.batchTimeout);
        }
    }

    /**
     * Añade items a la cola de reintentos
     * @param {Array} items - Items a reintentar
     * @param {number} retryCount - Número de reintento
     * @param {number} persistentId - ID en buffer persistente (opcional)
     */
    addToRetryQueue(items, retryCount = 1, persistentId = null) {
        const delay = Math.min(this.baseDelay * Math.pow(2, retryCount - 1), this.maxDelay);
        
        this.retryQueue.push({
            items,
            retryCount,
            persistentId,
            nextRetry: Date.now() + delay
        });

        this.scheduleRetry();
    }

    /**
     * Programa el próximo reintento
     */
    scheduleRetry() {
        if (this.retryTimer) return;

        const nextItem = this.retryQueue.find(item => item.nextRetry <= Date.now());
        if (!nextItem) return;

        this.retryTimer = setTimeout(() => {
            this.processRetryQueue();
        }, Math.max(0, nextItem.nextRetry - Date.now()));
    }

    /**
     * Procesa la cola de reintentos
     */
    async processRetryQueue() {
        this.retryTimer = null;

        const now = Date.now();
        const itemsToRetry = this.retryQueue.filter(item => item.nextRetry <= now);
        
        for (const item of itemsToRetry) {
            try {
                await this.sendToBackend(item.items);
                
                // ✅ Éxito: remover de cola de reintentos
                this.retryQueue = this.retryQueue.filter(q => q !== item);
                
                // Remover del buffer persistente si existe
                if (item.persistentId) {
                    await this.removeFromPersistentBuffer(item.persistentId);
                }
                
                console.log(`SyntropyFront: Reintento exitoso después de ${item.retryCount} intentos`);
            } catch (error) {
                console.warn(`SyntropyFront: Reintento ${item.retryCount} falló:`, error);
                
                if (item.retryCount >= this.maxRetries) {
                    // ❌ Máximo de reintentos alcanzado
                    this.retryQueue = this.retryQueue.filter(q => q !== item);
                    console.error('SyntropyFront: Item excedió máximo de reintentos, datos perdidos');
                } else {
                    // Programar próximo reintento
                    item.retryCount++;
                    item.nextRetry = Date.now() + Math.min(
                        this.baseDelay * Math.pow(2, item.retryCount - 1), 
                        this.maxDelay
                    );
                }
            }
        }

        // Programar próximo reintento si quedan items
        if (this.retryQueue.length > 0) {
            this.scheduleRetry();
        }
    }

    /**
     * Envía todos los items en cola
     */
    async flush() {
        if (this.queue.length === 0) return;

        const itemsToSend = [...this.queue];
        this.queue = [];

        if (this.batchTimer) {
            clearTimeout(this.batchTimer);
            this.batchTimer = null;
        }

        try {
            await this.sendToBackend(itemsToSend);
            console.log('SyntropyFront: Datos enviados exitosamente');
        } catch (error) {
            console.error('SyntropyFront Agent: Error enviando datos:', error);
            
            // ✅ REINTENTOS: Agregar a cola de reintentos
            this.addToRetryQueue(itemsToSend);
            
            // ✅ BUFFER PERSISTENTE: Guardar en IndexedDB
            if (this.usePersistentBuffer) {
                await this.saveToPersistentBuffer(itemsToSend);
            }
        }
    }

    /**
     * Envía datos al backend
     * @param {Array} items - Items a enviar
     */
    async sendToBackend(items) {
        const payload = {
            timestamp: new Date().toISOString(),
            items: items
        };

        // ✅ SERIALIZACIÓN ROBUSTA: Usar serializador que maneja referencias circulares
        let serializedPayload;
        try {
            serializedPayload = robustSerializer.serialize(payload);
        } catch (error) {
            console.error('SyntropyFront: Error en serialización del payload:', error);
            
            // Fallback: intentar serialización básica con información de error
            serializedPayload = JSON.stringify({
                __serializationError: true,
                error: error.message,
                timestamp: new Date().toISOString(),
                itemsCount: items.length,
                fallbackData: 'Serialización falló, datos no enviados'
            });
        }

        const response = await fetch(this.endpoint, {
            method: 'POST',
            headers: this.headers,
            body: serializedPayload
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        return response.json();
    }

    /**
     * Fuerza el envío inmediato de todos los datos pendientes
     */
    async forceFlush() {
        await this.flush();
        
        // También intentar enviar items en cola de reintentos
        if (this.retryQueue.length > 0) {
            console.log('SyntropyFront: Intentando enviar items en cola de reintentos...');
            await this.processRetryQueue();
        }
    }

    /**
     * Obtiene estadísticas del agent
     * @returns {Object} Estadísticas
     */
    getStats() {
        return {
            queueLength: this.queue.length,
            retryQueueLength: this.retryQueue.length,
            isEnabled: this.isEnabled,
            usePersistentBuffer: this.usePersistentBuffer,
            maxRetries: this.maxRetries
        };
    }

    /**
     * Desactiva el agent
     */
    disable() {
        this.isEnabled = false;
        this.queue = [];
        this.retryQueue = [];
        
        if (this.batchTimer) {
            clearTimeout(this.batchTimer);
            this.batchTimer = null;
        }
        
        if (this.retryTimer) {
            clearTimeout(this.retryTimer);
            this.retryTimer = null;
        }
    }
}

// Instancia singleton
const agent = new Agent();

/**
 * ContextCollector - Recolector dinámico de contexto
 * Sistema elegante para recolectar datos según lo que pida el usuario
 * Por defecto: Sets curados y seguros
 * Configuración específica: El usuario elige exactamente qué quiere
 */
class ContextCollector {
    constructor() {
        // Sets curados por defecto (seguros y útiles)
        this.defaultContexts = {
            device: {
                userAgent: () => navigator.userAgent,
                language: () => navigator.language,
                screen: () => ({
                    width: window.screen.width,
                    height: window.screen.height
                }),
                timezone: () => Intl.DateTimeFormat().resolvedOptions().timeZone
            },
            window: {
                url: () => window.location.href,
                viewport: () => ({
                    width: window.innerWidth,
                    height: window.innerHeight
                }),
                title: () => document.title
            },
            session: {
                sessionId: () => this.generateSessionId(),
                pageLoadTime: () => performance.now()
            },
            ui: {
                visibility: () => document.visibilityState,
                activeElement: () => document.activeElement ? {
                    tagName: document.activeElement.tagName
                } : null
            },
            network: {
                online: () => navigator.onLine,
                connection: () => navigator.connection ? {
                    effectiveType: navigator.connection.effectiveType
                } : null
            }
        };

        // Mapeo completo de todos los campos disponibles
        this.allFields = {
            device: {
                userAgent: () => navigator.userAgent,
                language: () => navigator.language,
                languages: () => navigator.languages,
                screen: () => ({
                    width: window.screen.width,
                    height: window.screen.height,
                    availWidth: window.screen.availWidth,
                    availHeight: window.screen.availHeight,
                    colorDepth: window.screen.colorDepth,
                    pixelDepth: window.screen.pixelDepth
                }),
                timezone: () => Intl.DateTimeFormat().resolvedOptions().timeZone,
                cookieEnabled: () => navigator.cookieEnabled,
                doNotTrack: () => navigator.doNotTrack
            },
            window: {
                url: () => window.location.href,
                pathname: () => window.location.pathname,
                search: () => window.location.search,
                hash: () => window.location.hash,
                referrer: () => document.referrer,
                title: () => document.title,
                viewport: () => ({
                    width: window.innerWidth,
                    height: window.innerHeight
                })
            },
            storage: {
                localStorage: () => {
                    const keys = Object.keys(localStorage);
                    return {
                        keys: keys.length,
                        size: JSON.stringify(localStorage).length,
                        keyNames: keys // Solo nombres, no valores
                    };
                },
                sessionStorage: () => {
                    const keys = Object.keys(sessionStorage);
                    return {
                        keys: keys.length,
                        size: JSON.stringify(sessionStorage).length,
                        keyNames: keys // Solo nombres, no valores
                    };
                }
            },
            network: {
                online: () => navigator.onLine,
                connection: () => navigator.connection ? {
                    effectiveType: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink,
                    rtt: navigator.connection.rtt
                } : null
            },
            ui: {
                focused: () => document.hasFocus(),
                visibility: () => document.visibilityState,
                activeElement: () => document.activeElement ? {
                    tagName: document.activeElement.tagName,
                    id: document.activeElement.id,
                    className: document.activeElement.className
                } : null
            },
            performance: {
                memory: () => window.performance && window.performance.memory ? {
                    used: Math.round(window.performance.memory.usedJSHeapSize / 1048576),
                    total: Math.round(window.performance.memory.totalJSHeapSize / 1048576),
                    limit: Math.round(window.performance.memory.jsHeapSizeLimit / 1048576)
                } : null,
                timing: () => window.performance ? {
                    navigationStart: window.performance.timing.navigationStart,
                    loadEventEnd: window.performance.timing.loadEventEnd
                } : null
            },
            session: {
                sessionId: () => this.generateSessionId(),
                startTime: () => new Date().toISOString(),
                pageLoadTime: () => performance.now()
            }
        };
    }

    /**
     * Recolecta contexto según la configuración
     * @param {Object} contextConfig - Configuración de contexto
     * @returns {Object} Contexto recolectado
     */
    collect(contextConfig = {}) {
        const context = {};

        Object.entries(contextConfig).forEach(([contextType, config]) => {
            try {
                if (config === true) {
                    // Usar set curado por defecto
                    context[contextType] = this.collectDefaultContext(contextType);
                } else if (Array.isArray(config)) {
                    // Configuración específica: array de campos
                    context[contextType] = this.collectSpecificFields(contextType, config);
                } else if (config === false) {
                    // Explícitamente deshabilitado
                    // No hacer nada
                } else {
                    console.warn(`SyntropyFront: Configuración de contexto inválida para ${contextType}:`, config);
                }
            } catch (error) {
                console.warn(`SyntropyFront: Error recolectando contexto ${contextType}:`, error);
                context[contextType] = { error: 'Failed to collect' };
            }
        });

        return context;
    }

    /**
     * Recolecta el set curado por defecto
     * @param {string} contextType - Tipo de contexto
     * @returns {Object} Contexto por defecto
     */
    collectDefaultContext(contextType) {
        const defaultContext = this.defaultContexts[contextType];
        if (!defaultContext) {
            console.warn(`SyntropyFront: No hay set por defecto para ${contextType}`);
            return {};
        }

        const result = {};
        Object.entries(defaultContext).forEach(([field, getter]) => {
            try {
                result[field] = getter();
            } catch (error) {
                console.warn(`SyntropyFront: Error recolectando campo ${field} de ${contextType}:`, error);
                result[field] = null;
            }
        });

        return result;
    }

    /**
     * Recolecta campos específicos
     * @param {string} contextType - Tipo de contexto
     * @param {Array} fields - Campos específicos a recolectar
     * @returns {Object} Contexto específico
     */
    collectSpecificFields(contextType, fields) {
        const allFields = this.allFields[contextType];
        if (!allFields) {
            console.warn(`SyntropyFront: Tipo de contexto desconocido: ${contextType}`);
            return {};
        }

        const result = {};
        fields.forEach(field => {
            try {
                if (allFields[field]) {
                    result[field] = allFields[field]();
                } else {
                    console.warn(`SyntropyFront: Campo ${field} no disponible en ${contextType}`);
                }
            } catch (error) {
                console.warn(`SyntropyFront: Error recolectando campo ${field} de ${contextType}:`, error);
                result[field] = null;
            }
        });

        return result;
    }

    /**
     * Genera un ID de sesión simple
     */
    generateSessionId() {
        if (!this._sessionId) {
            this._sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        return this._sessionId;
    }

    /**
     * Obtiene la lista de tipos de contexto disponibles
     * @returns {Array} Tipos disponibles
     */
    getAvailableTypes() {
        return Object.keys(this.allFields);
    }

    /**
     * Obtiene la lista de campos disponibles para un tipo de contexto
     * @param {string} contextType - Tipo de contexto
     * @returns {Array} Campos disponibles
     */
    getAvailableFields(contextType) {
        const fields = this.allFields[contextType];
        return fields ? Object.keys(fields) : [];
    }

    /**
     * Obtiene información sobre los sets por defecto
     * @returns {Object} Información de sets por defecto
     */
    getDefaultContextsInfo() {
        const info = {};
        Object.entries(this.defaultContexts).forEach(([type, fields]) => {
            info[type] = Object.keys(fields);
        });
        return info;
    }
}

// Instancia singleton
const contextCollector = new ContextCollector();

/**
 * Interceptors - Observadores que capturan eventos automáticamente
 * Implementa Chaining Pattern para coexistir con otros APMs
 */
class Interceptors {
    constructor() {
        this.isInitialized = false;
        this.config = {
            captureClicks: true,
            captureFetch: true,
            captureErrors: true,
            captureUnhandledRejections: true
        };
        this.contextTypes = [];
        
        // Referencias originales para restaurar en destroy()
        this.originalHandlers = {
            fetch: null,
            onerror: null,
            onunhandledrejection: null
        };
        
        // Event listeners para limpiar
        this.eventListeners = new Map();
    }

    /**
     * Configura los interceptores
     * @param {Object} config - Configuración de interceptores
     */
    configure(config) {
        this.config = { ...this.config, ...config };
        this.contextTypes = config.context || [];
    }

    /**
     * Inicializa todos los interceptores
     */
    init() {
        if (this.isInitialized) {
            console.warn('SyntropyFront: Interceptors ya están inicializados');
            return;
        }

        if (this.config.captureClicks) {
            this.setupClickInterceptor();
        }

        if (this.config.captureFetch) {
            this.setupFetchInterceptor();
        }

        if (this.config.captureErrors || this.config.captureUnhandledRejections) {
            this.setupErrorInterceptors();
        }

        this.isInitialized = true;
        console.log('SyntropyFront: Interceptors inicializados con Chaining Pattern');
    }

    /**
     * Intercepta clics de usuario
     */
    setupClickInterceptor() {
        const clickHandler = (event) => {
            const el = event.target;
            if (!el) return;
            
            // Genera un selector CSS simple para identificar el elemento
            let selector = el.tagName.toLowerCase();
            if (el.id) {
                selector += `#${el.id}`;
            } else if (el.className && typeof el.className === 'string') {
                selector += `.${el.className.split(' ').filter(Boolean).join('.')}`;
            }

            breadcrumbStore.add({
                category: 'ui',
                message: `Usuario hizo click en '${selector}'`,
                data: {
                    selector,
                    tagName: el.tagName,
                    id: el.id,
                    className: el.className
                }
            });
        };

        // Guardar referencia para limpiar después
        this.eventListeners.set('click', clickHandler);
        document.addEventListener('click', clickHandler, true);
    }

    /**
     * Intercepta llamadas de red (fetch) con Chaining
     */
    setupFetchInterceptor() {
        // Guardar referencia original
        this.originalHandlers.fetch = window.fetch;
        
        // Crear nuevo handler que encadena con el original
        const syntropyFetchHandler = (...args) => {
            const url = args[0] instanceof Request ? args[0].url : args[0];
            const method = args[0] instanceof Request ? args[0].method : (args[1]?.method || 'GET');
            
            breadcrumbStore.add({
                category: 'network',
                message: `Request: ${method} ${url}`,
                data: {
                    url,
                    method,
                    timestamp: Date.now()
                }
            });

            // ✅ CHAINING: Llamar al handler original
            return this.originalHandlers.fetch.apply(window, args);
        };

        // Sobrescribir con el nuevo handler
        window.fetch = syntropyFetchHandler;
    }

    /**
     * Intercepta errores globales con Chaining
     */
    setupErrorInterceptors() {
        if (this.config.captureErrors) {
            // Guardar referencia original
            this.originalHandlers.onerror = window.onerror;
            
            // Crear nuevo handler que encadena con el original
            const syntropyErrorHandler = (message, source, lineno, colno, error) => {
                const errorPayload = {
                    type: 'uncaught_exception',
                    error: { 
                        message, 
                        source, 
                        lineno, 
                        colno, 
                        stack: error?.stack 
                    },
                    breadcrumbs: breadcrumbStore.getAll(),
                    timestamp: new Date().toISOString()
                };

                this.handleError(errorPayload);
                
                // ✅ CHAINING: Llamar al handler original si existe
                if (this.originalHandlers.onerror) {
                    try {
                        return this.originalHandlers.onerror(message, source, lineno, colno, error);
                    } catch (originalError) {
                        console.warn('SyntropyFront: Error en handler original:', originalError);
                        return false;
                    }
                }
                
                return false; // No prevenir el error por defecto
            };

            // Sobrescribir con el nuevo handler
            window.onerror = syntropyErrorHandler;
        }

        if (this.config.captureUnhandledRejections) {
            // Guardar referencia original
            this.originalHandlers.onunhandledrejection = window.onunhandledrejection;
            
            // Crear nuevo handler que encadena con el original
            const syntropyRejectionHandler = (event) => {
                const errorPayload = {
                    type: 'unhandled_rejection',
                    error: {
                        message: event.reason?.message || 'Rechazo de promesa sin mensaje',
                        stack: event.reason?.stack,
                    },
                    breadcrumbs: breadcrumbStore.getAll(),
                    timestamp: new Date().toISOString()
                };

                this.handleError(errorPayload);
                
                // ✅ CHAINING: Llamar al handler original si existe
                if (this.originalHandlers.onunhandledrejection) {
                    try {
                        this.originalHandlers.onunhandledrejection(event);
                    } catch (originalError) {
                        console.warn('SyntropyFront: Error en handler original de rejection:', originalError);
                    }
                }
            };

            // Sobrescribir con el nuevo handler
            window.onunhandledrejection = syntropyRejectionHandler;
        }
    }

    /**
     * Maneja los errores capturados
     * @param {Object} errorPayload - Payload del error
     */
    handleError(errorPayload) {
        // Recolectar contexto si está configurado
        const context = this.contextTypes.length > 0 ? contextCollector.collect(this.contextTypes) : null;
        
        // Enviar al agent si está configurado
        agent.sendError(errorPayload, context);
        
        // Callback para manejo personalizado de errores
        if (this.onError) {
            this.onError(errorPayload);
        } else {
            // Comportamiento por defecto: log a consola
            console.error('SyntropyFront - Error detectado:', errorPayload);
        }
    }

    /**
     * Desactiva todos los interceptores y restaura handlers originales
     */
    destroy() {
        if (!this.isInitialized) return;

        console.log('SyntropyFront: Limpiando interceptores...');

        // ✅ RESTAURAR: Handlers originales
        if (this.originalHandlers.fetch) {
            window.fetch = this.originalHandlers.fetch;
            console.log('SyntropyFront: fetch original restaurado');
        }

        if (this.originalHandlers.onerror) {
            window.onerror = this.originalHandlers.onerror;
            console.log('SyntropyFront: onerror original restaurado');
        }

        if (this.originalHandlers.onunhandledrejection) {
            window.onunhandledrejection = this.originalHandlers.onunhandledrejection;
            console.log('SyntropyFront: onunhandledrejection original restaurado');
        }

        // ✅ LIMPIAR: Event listeners
        this.eventListeners.forEach((handler, eventType) => {
            document.removeEventListener(eventType, handler, true);
            console.log(`SyntropyFront: Event listener ${eventType} removido`);
        });

        // Limpiar referencias
        this.originalHandlers = {
            fetch: null,
            onerror: null,
            onunhandledrejection: null
        };
        this.eventListeners.clear();
        this.isInitialized = false;

        console.log('SyntropyFront: Interceptors destruidos y handlers restaurados');
    }

    /**
     * Obtiene información sobre los handlers originales
     * @returns {Object} Información de handlers
     */
    getHandlerInfo() {
        return {
            isInitialized: this.isInitialized,
            hasOriginalFetch: !!this.originalHandlers.fetch,
            hasOriginalOnError: !!this.originalHandlers.onerror,
            hasOriginalOnUnhandledRejection: !!this.originalHandlers.onunhandledrejection,
            eventListenersCount: this.eventListeners.size
        };
    }
}

// Instancia singleton
const interceptors = new Interceptors();

/**
 * Presets de configuración para SyntropyFront
 * Recetas pre-configuradas para diferentes casos de uso
 * 
 * @author SyntropyFront Team
 * @version 1.0.0
 */

/**
 * Preset 'safe' - Modo solo emergencias
 * Ideal para: Producción, aplicaciones críticas, GDPR estricto
 */
const SAFE_PRESET = {
    name: 'safe',
    description: 'Modo solo emergencias - Mínimo impacto, máxima privacidad',
    
    // Configuración del agent
    agent: {
        batchTimeout: null, // Solo errores
        batchSize: 5,
        encrypt: null // Sin encriptación por defecto
    },
    
    // Breadcrumbs limitados
    maxBreadcrumbs: 10,
    
    // Contexto mínimo
    context: {
        device: true,     // Solo información básica del dispositivo
        window: false,    // No URL ni viewport
        session: true,    // Solo sessionId
        ui: false,        // No información de UI
        network: false    // No información de red
    },
    
    // Sin tracking de objetos
    customObjects: {},
    proxyTracking: false,
    
    // Interceptores básicos
    captureClicks: false,
    captureFetch: false,
    captureErrors: true,
    captureUnhandledRejections: true,
    
    // Worker opcional
    useWorker: false,
    
    // Callbacks
    onError: null,
    onBreadcrumbAdded: null
};

/**
 * Preset 'balanced' - Modo equilibrado
 * Ideal para: Desarrollo, testing, aplicaciones generales
 */
const BALANCED_PRESET = {
    name: 'balanced',
    description: 'Modo equilibrado - Balance entre información y performance',
    
    // Configuración del agent
    agent: {
        batchTimeout: 10000, // Envío cada 10 segundos
        batchSize: 20,
        encrypt: null
    },
    
    // Breadcrumbs moderados
    maxBreadcrumbs: 50,
    
    // Contexto curado
    context: {
        device: true,     // Información completa del dispositivo
        window: true,     // URL y viewport
        session: true,    // Información de sesión
        ui: true,         // Estado básico de UI
        network: true     // Estado de conectividad
    },
    
    // Tracking de objetos moderado
    customObjects: {},
    proxyTracking: {
        enabled: true,
        maxStates: 10,
        trackNested: true,
        trackArrays: false
    },
    
    // Interceptores completos
    captureClicks: true,
    captureFetch: true,
    captureErrors: true,
    captureUnhandledRejections: true,
    
    // Worker habilitado
    useWorker: true,
    
    // Callbacks
    onError: null,
    onBreadcrumbAdded: null
};

/**
 * Preset 'debug' - Modo debug completo
 * Ideal para: Desarrollo, debugging, análisis profundo
 */
const DEBUG_PRESET = {
    name: 'debug',
    description: 'Modo debug completo - Máxima información para desarrollo',
    
    // Configuración del agent
    agent: {
        batchTimeout: 5000, // Envío cada 5 segundos
        batchSize: 50,
        encrypt: null
    },
    
    // Breadcrumbs completos
    maxBreadcrumbs: 100,
    
    // Contexto completo
    context: {
        device: true,     // Todo del dispositivo
        window: true,     // Todo de la ventana
        session: true,    // Todo de la sesión
        ui: true,         // Todo de la UI
        network: true     // Todo de la red
    },
    
    // Tracking de objetos completo
    customObjects: {},
    proxyTracking: {
        enabled: true,
        maxStates: 20,
        trackNested: true,
        trackArrays: true,
        trackFunctions: true
    },
    
    // Todos los interceptores
    captureClicks: true,
    captureFetch: true,
    captureErrors: true,
    captureUnhandledRejections: true,
    
    // Worker habilitado
    useWorker: true,
    
    // Callbacks para debugging
    onError: (error) => {
        console.error('SyntropyFront Error:', error);
    },
    onBreadcrumbAdded: (breadcrumb) => {
        console.log('SyntropyFront Breadcrumb:', breadcrumb);
    }
};

/**
 * Preset 'performance' - Modo optimizado para performance
 * Ideal para: Aplicaciones de alta performance, gaming, real-time
 */
const PERFORMANCE_PRESET = {
    name: 'performance',
    description: 'Modo performance - Máxima velocidad, información mínima',
    
    // Configuración del agent
    agent: {
        batchTimeout: null, // Solo errores críticos
        batchSize: 3,
        encrypt: null
    },
    
    // Breadcrumbs mínimos
    maxBreadcrumbs: 5,
    
    // Contexto mínimo
    context: {
        device: false,    // Sin información de dispositivo
        window: false,    // Sin información de ventana
        session: true,    // Solo sessionId
        ui: false,        // Sin información de UI
        network: false    // Sin información de red
    },
    
    // Sin tracking de objetos
    customObjects: {},
    proxyTracking: false,
    
    // Solo errores críticos
    captureClicks: false,
    captureFetch: false,
    captureErrors: true,
    captureUnhandledRejections: true,
    
    // Sin worker para máxima velocidad
    useWorker: false,
    
    // Sin callbacks
    onError: null,
    onBreadcrumbAdded: null
};

/**
 * Mapa de presets disponibles
 */
const PRESETS = {
    safe: SAFE_PRESET,
    balanced: BALANCED_PRESET,
    debug: DEBUG_PRESET,
    performance: PERFORMANCE_PRESET
};

/**
 * Obtiene un preset por nombre
 */
function getPreset(name) {
    const preset = PRESETS[name];
    if (!preset) {
        throw new Error(`Preset '${name}' no encontrado. Presets disponibles: ${Object.keys(PRESETS).join(', ')}`);
    }
    return preset;
}

/**
 * Lista todos los presets disponibles
 */
function getAvailablePresets() {
    return Object.keys(PRESETS).map(name => ({
        name,
        ...PRESETS[name]
    }));
}

/**
 * Obtiene información de un preset
 */
function getPresetInfo(name) {
    const preset = getPreset(name);
    return {
        name: preset.name,
        description: preset.description,
        features: {
            breadcrumbs: preset.maxBreadcrumbs,
            context: Object.keys(preset.context).filter(key => preset.context[key]).length,
            worker: preset.useWorker,
            proxyTracking: preset.proxyTracking?.enabled || false,
            agentMode: preset.agent.batchTimeout ? 'completo' : 'solo emergencias'
        }
    };
}

/**
 * SyntropyFront - Sistema de trazabilidad para frontend
 * API principal para inicializar y configurar el sistema
 */
class SyntropyFront {
    constructor() {
        this.isInitialized = false;
        this.currentPreset = null;
        
        // Lazy-loaded modules
        this.proxyObjectTracker = null;
        this.interceptorRegistry = null;
        this.workerManager = null;
        
        // Configuración por defecto (balanced preset)
        this.config = {
            preset: 'balanced', // Preset por defecto
            maxBreadcrumbs: 50,
            captureClicks: true,
            captureFetch: true,
            captureErrors: true,
            captureUnhandledRejections: true,
            onError: null,
            onBreadcrumbAdded: null,
            // Configuración del agent
            agent: {
                endpoint: null,
                headers: {},
                batchSize: 20,
                batchTimeout: 10000, // 10 segundos por defecto
                encrypt: null // Callback de encriptación opcional
            },
            // Configuración de contexto (nueva arquitectura granular)
            context: {
                device: true,    // Set curado por defecto
                window: true,    // Set curado por defecto
                session: true,   // Set curado por defecto
                ui: true,        // Set curado por defecto
                network: true    // Set curado por defecto
            },
            // Configuración de proxy tracking
            proxyTracking: {
                enabled: true,
                maxStates: 10,
                trackNested: true,
                trackArrays: false
            },
            // Worker habilitado por defecto
            useWorker: true
        };
    }

    /**
     * Inicializa el sistema de trazabilidad
     * @param {Object} options - Opciones de configuración
     */
    async init(options = {}) {
        if (this.isInitialized) {
            console.warn('SyntropyFront ya está inicializado');
            return;
        }

        // Manejar preset si se especifica
        if (options.preset) {
            try {
                const preset = getPreset(options.preset);
                this.currentPreset = options.preset;
                
                // Aplicar configuración del preset
                this.config = { ...this.config, ...preset };
                
                console.log(`🎯 SyntropyFront: Aplicando preset '${options.preset}' - ${preset.description}`);
            } catch (error) {
                console.error(`❌ SyntropyFront: Error aplicando preset '${options.preset}':`, error.message);
                throw error;
            }
        }

        // Aplicar configuración personalizada (sobrescribe preset)
        this.config = { ...this.config, ...options };

        // Configurar agent primero
        if (this.config.agent.endpoint) {
            agent.configure(this.config.agent);
        }

        // Configurar worker manager
        if (this.config.useWorker !== false) {
            await this.workerManager.init({
                maxBreadcrumbs: this.config.maxBreadcrumbs,
                agent: this.config.agent
            });
        }

        // Configurar breadcrumb store
        breadcrumbStore.setMaxBreadcrumbs(this.config.maxBreadcrumbs);
        breadcrumbStore.onBreadcrumbAdded = this.config.onBreadcrumbAdded;
        breadcrumbStore.setAgent(agent);

        // Configurar contexto (nueva arquitectura granular)
        this.contextConfig = this.config.context || {
            device: true,
            window: true,
            session: true,
            ui: true,
            network: true
        };



        // Lazy load modules based on configuration
        await this.loadModules();

        // Configurar proxy object tracker (si está habilitado)
        if (this.config.proxyTracking?.enabled && this.proxyObjectTracker) {
            this.proxyObjectTracker.configure(this.config.proxyTracking);
        }

        // Configurar interceptores
        interceptors.configure({
            captureClicks: this.config.captureClicks,
            captureFetch: this.config.captureFetch,
            captureErrors: this.config.captureErrors,
            captureUnhandledRejections: this.config.captureUnhandledRejections
        });

        interceptors.onError = this.config.onError;

        // Inicializar interceptores
        interceptors.init();

        // Inicializar interceptores personalizados (si están habilitados)
        if (this.interceptorRegistry) {
            this.interceptorRegistry.init({
                breadcrumbStore,
                agent,
                contextCollector
            });
        }

        this.isInitialized = true;
        console.log('SyntropyFront inicializado correctamente');
    }

    /**
     * Carga módulos dinámicamente basado en la configuración
     */
    async loadModules() {
        const loadPromises = [];

        // Cargar ProxyObjectTracker si está habilitado
        if (this.config.proxyTracking?.enabled) {
            loadPromises.push(
                Promise.resolve().then(function () { return ProxyObjectTracker$1; })
                    .then(module => {
                        this.proxyObjectTracker = module.proxyObjectTracker;
                        console.log('🔄 ProxyObjectTracker cargado dinámicamente');
                    })
                    .catch(error => {
                        console.warn('⚠️ Error cargando ProxyObjectTracker:', error);
                    })
            );
        }

        // Cargar InterceptorRegistry si hay interceptores personalizados
        if (this.config.useInterceptors !== false) {
            loadPromises.push(
                Promise.resolve().then(function () { return InterceptorRegistry$1; })
                    .then(module => {
                        this.interceptorRegistry = module.interceptorRegistry;
                        console.log('🔄 InterceptorRegistry cargado dinámicamente');
                    })
                    .catch(error => {
                        console.warn('⚠️ Error cargando InterceptorRegistry:', error);
                    })
            );
        }

        // Cargar WorkerManager si está habilitado
        if (this.config.useWorker !== false) {
            loadPromises.push(
                Promise.resolve().then(function () { return WorkerManager$1; })
                    .then(module => {
                        this.workerManager = new module.default();
                        console.log('🔄 WorkerManager cargado dinámicamente');
                    })
                    .catch(error => {
                        console.warn('⚠️ Error cargando WorkerManager:', error);
                    })
            );
        }

        // Esperar a que todos los módulos se carguen
        await Promise.all(loadPromises);
    }

    /**
     * Añade un breadcrumb manualmente
     * @param {string} category - Categoría del evento
     * @param {string} message - Mensaje descriptivo
     * @param {Object} data - Datos adicionales
     */
    addBreadcrumb(category, message, data = {}) {
        breadcrumbStore.add({ category, message, data });
    }

    /**
     * Obtiene todos los breadcrumbs
     * @returns {Array} Lista de breadcrumbs
     */
    getBreadcrumbs() {
        return breadcrumbStore.getAll();
    }

    /**
     * Obtiene breadcrumbs por categoría
     * @param {string} category - Categoría a filtrar
     * @returns {Array} Breadcrumbs de la categoría
     */
    getBreadcrumbsByCategory(category) {
        return breadcrumbStore.getByCategory(category);
    }

    /**
     * Limpia todos los breadcrumbs
     */
    clearBreadcrumbs() {
        breadcrumbStore.clear();
    }

    /**
     * Desactiva el sistema de trazabilidad
     */
    destroy() {
        if (!this.isInitialized) return;

        interceptors.destroy();
        
        if (this.interceptorRegistry) {
            this.interceptorRegistry.destroy();
        }
        
        breadcrumbStore.clear();
        agent.disable();
        
        if (this.workerManager) {
            this.workerManager.destroy();
        }
        
        this.isInitialized = false;
        console.log('SyntropyFront desactivado');
    }

    /**
     * Configura el tamaño máximo de breadcrumbs
     * @param {number} maxBreadcrumbs - Nuevo tamaño máximo
     */
    setMaxBreadcrumbs(maxBreadcrumbs) {
        breadcrumbStore.setMaxBreadcrumbs(maxBreadcrumbs);
    }

    /**
     * Obtiene el tamaño máximo actual de breadcrumbs
     * @returns {number} Tamaño máximo
     */
    getMaxBreadcrumbs() {
        return breadcrumbStore.getMaxBreadcrumbs();
    }

    /**
     * Fuerza el envío de datos pendientes al backend
     */
    async flush() {
        await agent.forceFlush();
    }

    /**
     * Obtiene el contexto actual según la configuración
     * @returns {Object} Contexto recolectado
     */
    getContext() {
        const context = contextCollector.collect(this.contextConfig);
        
        // Agregar objetos personalizados
        const customObjects = customObjectCollector.collectCustomObjects();
        if (Object.keys(customObjects).length > 0) {
            context.customObjects = customObjects;
        }
        
        return context;
    }

    /**
     * Obtiene todos los tipos de contexto disponibles
     * @returns {Array} Tipos disponibles
     */
    getAvailableContextTypes() {
        return contextCollector.getAvailableTypes();
    }

    /**
     * Obtiene los campos disponibles para un tipo de contexto
     * @param {string} contextType - Tipo de contexto
     * @returns {Array} Campos disponibles
     */
    getAvailableContextFields(contextType) {
        return contextCollector.getAvailableFields(contextType);
    }

    /**
     * Obtiene información sobre los sets por defecto
     * @returns {Object} Información de sets por defecto
     */
    getDefaultContextsInfo() {
        return contextCollector.getDefaultContextsInfo();
    }

    /**
     * Configura el contexto a recolectar
     * @param {Object} contextConfig - Configuración de contexto
     */
    setContext(contextConfig) {
        if (typeof contextConfig !== 'object') {
            console.warn('SyntropyFront: contextConfig debe ser un objeto');
            return;
        }

        this.contextConfig = contextConfig;
        console.log('SyntropyFront: Configuración de contexto actualizada:', contextConfig);
    }

    /**
     * Configura los tipos de contexto a recolectar (método legacy)
     * @param {Array} contextTypes - Tipos de contexto
     */
    setContextTypes(contextTypes) {
        if (!Array.isArray(contextTypes)) {
            console.warn('SyntropyFront: contextTypes debe ser un array');
            return;
        }

        // Convertir array a configuración por defecto
        const contextConfig = {};
        contextTypes.forEach(type => {
            contextConfig[type] = true; // Usar set por defecto
        });

        this.setContext(contextConfig);
    }

    // ===== DEPRECATED: CUSTOM OBJECT METHODS =====
    // Estos métodos están deprecados. Usa ProxyObjectTracker en su lugar.
    
    /**
     * @deprecated Usa addProxyObject() en su lugar
     */
    addCustomObject(name, source, maxStates = 10) {
        console.warn('SyntropyFront: addCustomObject() está deprecado. Usa addProxyObject() en su lugar.');
        throw new Error('addCustomObject() está deprecado. Usa addProxyObject() en su lugar.');
    }

    /**
     * @deprecated Usa removeProxyObject() en su lugar
     */
    removeCustomObject(name) {
        console.warn('SyntropyFront: removeCustomObject() está deprecado. Usa removeProxyObject() en su lugar.');
        throw new Error('removeCustomObject() está deprecado. Usa removeProxyObject() en su lugar.');
    }

    /**
     * @deprecated Usa getProxyObjectState() en su lugar
     */
    getCustomObjectValue(name) {
        console.warn('SyntropyFront: getCustomObjectValue() está deprecado. Usa getProxyObjectState() en su lugar.');
        throw new Error('getCustomObjectValue() está deprecado. Usa getProxyObjectState() en su lugar.');
    }

    /**
     * @deprecated Usa getProxyObjectHistory() en su lugar
     */
    getCustomObjectHistory(name) {
        console.warn('SyntropyFront: getCustomObjectHistory() está deprecado. Usa getProxyObjectHistory() en su lugar.');
        throw new Error('getCustomObjectHistory() está deprecado. Usa getProxyObjectHistory() en su lugar.');
    }

    /**
     * @deprecated Usa getProxyTrackedObjects() en su lugar
     */
    getCustomObjectNames() {
        console.warn('SyntropyFront: getCustomObjectNames() está deprecado. Usa getProxyTrackedObjects() en su lugar.');
        throw new Error('getCustomObjectNames() está deprecado. Usa getProxyTrackedObjects() en su lugar.');
    }

    /**
     * Inyecta un interceptor personalizado
     * @param {string} name - Nombre del interceptor
     * @param {Object} interceptor - Objeto interceptor con métodos init/destroy
     * @returns {SyntropyFront} Instancia para chaining
     */
    inject(name, interceptor) {
        if (!this.interceptorRegistry) {
            console.warn('SyntropyFront: InterceptorRegistry no está cargado. Asegúrate de que useInterceptors no esté en false.');
            return this;
        }
        this.interceptorRegistry.register(name, interceptor);
        return this; // Para chaining
    }

    /**
     * Remueve un interceptor personalizado
     * @param {string} name - Nombre del interceptor
     */
    removeInterceptor(name) {
        if (!this.interceptorRegistry) {
            console.warn('SyntropyFront: InterceptorRegistry no está cargado.');
            return;
        }
        this.interceptorRegistry.unregister(name);
    }

    /**
     * Obtiene la lista de interceptores registrados
     * @returns {Array} Lista de nombres de interceptores
     */
    getRegisteredInterceptors() {
        if (!this.interceptorRegistry) {
            return [];
        }
        return this.interceptorRegistry.getRegisteredInterceptors();
    }

    /**
     * Obtiene información de un interceptor específico
     * @param {string} name - Nombre del interceptor
     * @returns {Object|null} Información del interceptor
     */
    getInterceptorInfo(name) {
        if (!this.interceptorRegistry) {
            return null;
        }
        return this.interceptorRegistry.getInterceptorInfo(name);
    }

    /**
     * Verifica si está inicializado
     * @returns {boolean} Estado de inicialización
     */
    isActive() {
        return this.isInitialized;
    }

    // ===== PROXY OBJECT TRACKER METHODS =====

    /**
     * Agrega un objeto para tracking reactivo con Proxy
     * @param {string} objectPath - Ruta/nombre del objeto
     * @param {Object} targetObject - Objeto a trackear
     * @param {Object} options - Opciones de tracking
     * @returns {Object} Proxy del objeto original
     */
    addProxyObject(objectPath, targetObject, options = {}) {
        if (!this.proxyObjectTracker) {
            console.warn('SyntropyFront: ProxyObjectTracker no está cargado. Asegúrate de que proxyTracking.enabled esté en true.');
            return targetObject;
        }
        return this.proxyObjectTracker.addObject(objectPath, targetObject, options);
    }

    /**
     * Obtiene el historial de estados de un objeto trackeado
     * @param {string} objectPath - Ruta del objeto
     * @returns {Array} Historial de estados
     */
    getProxyObjectHistory(objectPath) {
        if (!this.proxyObjectTracker) {
            return [];
        }
        return this.proxyObjectTracker.getObjectHistory(objectPath);
    }

    /**
     * Obtiene el estado actual de un objeto trackeado
     * @param {string} objectPath - Ruta del objeto
     * @returns {Object|null} Estado actual
     */
    getProxyObjectState(objectPath) {
        if (!this.proxyObjectTracker) {
            return null;
        }
        return this.proxyObjectTracker.getCurrentState(objectPath);
    }

    /**
     * Obtiene todos los objetos trackeados con Proxy
     * @returns {Array} Lista de objetos trackeados
     */
    getProxyTrackedObjects() {
        if (!this.proxyObjectTracker) {
            return [];
        }
        return this.proxyObjectTracker.getTrackedObjects();
    }

    /**
     * Remueve un objeto del tracking con Proxy
     * @param {string} objectPath - Ruta del objeto
     * @returns {Object|null} Objeto original (sin proxy)
     */
    removeProxyObject(objectPath) {
        if (!this.proxyObjectTracker) {
            return null;
        }
        return this.proxyObjectTracker.removeObject(objectPath);
    }

    /**
     * Limpia todos los objetos trackeados con Proxy
     */
    clearProxyObjects() {
        if (!this.proxyObjectTracker) {
            return;
        }
        this.proxyObjectTracker.clear();
    }

    /**
     * Obtiene estadísticas del ProxyObjectTracker
     * @returns {Object} Estadísticas
     */
    getProxyTrackerStats() {
        if (!this.proxyObjectTracker) {
            return { enabled: false, trackedObjects: 0 };
        }
        return this.proxyObjectTracker.getStats();
    }

    // Worker Manager Methods
    async addBreadcrumbToWorker(type, message, data = {}) {
        if (!this.workerManager) {
            console.warn('SyntropyFront: WorkerManager no está cargado. Asegúrate de que useWorker no esté en false.');
            return this.addBreadcrumb(type, message, data);
        }
        if (this.workerManager.isWorkerAvailable()) {
            return await this.workerManager.addBreadcrumb(type, message, data);
        } else {
            // Fallback al método normal
            return this.addBreadcrumb(type, message, data);
        }
    }

    async getBreadcrumbsFromWorker() {
        if (!this.workerManager) {
            return this.getBreadcrumbs();
        }
        if (this.workerManager.isWorkerAvailable()) {
            return await this.workerManager.getBreadcrumbs();
        } else {
            return this.getBreadcrumbs();
        }
    }

    async clearBreadcrumbsFromWorker() {
        if (!this.workerManager) {
            return this.clearBreadcrumbs();
        }
        if (this.workerManager.isWorkerAvailable()) {
            return await this.workerManager.clearBreadcrumbs();
        } else {
            return this.clearBreadcrumbs();
        }
    }

    async sendErrorToWorker(error, context = {}) {
        if (!this.workerManager) {
            console.warn('SyntropyFront: WorkerManager no está cargado. Asegúrate de que useWorker no esté en false.');
            return this.sendError(error, context);
        }
        if (this.workerManager.isWorkerAvailable()) {
            return await this.workerManager.sendError(error, context);
        } else {
            // Fallback al método normal
            return this.sendError(error, context);
        }
    }

    async pingWorker() {
        if (!this.workerManager) {
            return { success: false, message: 'Worker no cargado' };
        }
        if (this.workerManager.isWorkerAvailable()) {
            return await this.workerManager.ping();
        } else {
            return { success: false, message: 'Worker no disponible' };
        }
    }

    getWorkerStatus() {
        if (!this.workerManager) {
            return { isAvailable: false, isInitialized: false, pendingRequests: 0 };
        }
        return this.workerManager.getStatus();
    }

    isWorkerAvailable() {
        if (!this.workerManager) {
            return false;
        }
        return this.workerManager.isWorkerAvailable();
    }

    // Preset Methods
    getCurrentPreset() {
        return this.currentPreset;
    }

    getPresetInfo(presetName = null) {
        const name = presetName || this.currentPreset;
        if (!name) {
            return null;
        }
        return getPresetInfo(name);
    }

    getAvailablePresets() {
        return getAvailablePresets();
    }

    async changePreset(presetName, options = {}) {
        if (this.isInitialized) {
            console.warn('SyntropyFront: No se puede cambiar preset después de la inicialización');
            return false;
        }

        try {
            const preset = getPreset(presetName);
            this.currentPreset = presetName;
            
            // Aplicar preset
            this.config = { ...this.config, ...preset };
            
            // Aplicar opciones adicionales
            this.config = { ...this.config, ...options };
            
            console.log(`🎯 SyntropyFront: Preset cambiado a '${presetName}' - ${preset.description}`);
            return true;
        } catch (error) {
            console.error(`❌ SyntropyFront: Error cambiando preset a '${presetName}':`, error.message);
            return false;
        }
    }

    getConfiguration() {
        return {
            currentPreset: this.currentPreset,
            config: this.config,
            isInitialized: this.isInitialized
        };
    }
}

// Instancia singleton principal
const syntropyFront = new SyntropyFront();

/**
 * ProxyObjectTracker - Tracking reactivo de objetos usando Proxy
 * Captura cambios en tiempo real sin necesidad de polling
 */
class ProxyObjectTracker {
    constructor() {
        this.trackedObjects = new Map(); // Map<objectPath, ProxyInfo>
        this.maxStates = 10; // Estados máximos por objeto
        this.isEnabled = true;
        this.onChangeCallback = null; // Callback cuando cambia un objeto
    }

    /**
     * Configura el tracker
     * @param {Object} config - Configuración
     * @param {number} [config.maxStates] - Máximo número de estados por objeto
     * @param {Function} [config.onChange] - Callback cuando cambia un objeto
     */
    configure(config = {}) {
        this.maxStates = config.maxStates || this.maxStates;
        this.onChangeCallback = config.onChange || null;
        this.isEnabled = config.enabled !== false;
    }

    /**
     * Agrega un objeto para tracking reactivo
     * @param {string} objectPath - Ruta/nombre del objeto
     * @param {Object} targetObject - Objeto a trackear
     * @param {Object} options - Opciones de tracking
     * @returns {Object} Proxy del objeto original
     */
    addObject(objectPath, targetObject, options = {}) {
        if (!this.isEnabled) {
            console.warn('SyntropyFront: ProxyObjectTracker deshabilitado');
            return targetObject;
        }

        if (!targetObject || typeof targetObject !== 'object') {
            console.warn(`SyntropyFront: Objeto inválido para tracking: ${objectPath}`);
            return targetObject;
        }

        // Verificar si ya está siendo trackeado
        if (this.trackedObjects.has(objectPath)) {
            console.warn(`SyntropyFront: Objeto ya está siendo trackeado: ${objectPath}`);
            return this.trackedObjects.get(objectPath).proxy;
        }

        try {
            // Crear estado inicial
            const initialState = {
                value: this.deepClone(targetObject),
                timestamp: new Date().toISOString(),
                changeType: 'initial'
            };

            // Crear info del objeto trackeado
            const proxyInfo = {
                objectPath,
                originalObject: targetObject,
                states: [initialState],
                proxy: null,
                options: {
                    trackNested: options.trackNested !== false,
                    trackArrays: options.trackArrays !== false,
                    trackFunctions: options.trackFunctions !== false,
                    maxDepth: options.maxDepth || 5
                }
            };

            // Crear Proxy
            const proxy = this.createProxy(targetObject, proxyInfo);
            proxyInfo.proxy = proxy;

            // Guardar en el mapa
            this.trackedObjects.set(objectPath, proxyInfo);

            console.log(`SyntropyFront: Objeto agregado para tracking reactivo: ${objectPath}`);
            return proxy;

        } catch (error) {
            console.error(`SyntropyFront: Error creando proxy para ${objectPath}:`, error);
            return targetObject;
        }
    }

    /**
     * Crea un Proxy que intercepta cambios
     * @param {Object} target - Objeto objetivo
     * @param {Object} proxyInfo - Información del proxy
     * @param {number} depth - Profundidad actual
     * @returns {Proxy} Proxy del objeto
     */
    createProxy(target, proxyInfo, depth = 0) {
        const { objectPath, options } = proxyInfo;

        return new Proxy(target, {
            get: (obj, prop) => {
                const value = obj[prop];

                // Si es un objeto/array y queremos trackear anidados
                if (options.trackNested && 
                    depth < options.maxDepth && 
                    value && 
                    typeof value === 'object' && 
                    !(value instanceof Date) && 
                    !(value instanceof RegExp) &&
                    !(value instanceof Error)) {
                    
                    // Crear proxy para objetos anidados
                    if (Array.isArray(value) && options.trackArrays) {
                        return this.createArrayProxy(value, proxyInfo, depth + 1);
                    } else if (!Array.isArray(value)) {
                        return this.createProxy(value, proxyInfo, depth + 1);
                    }
                }

                return value;
            },

            set: (obj, prop, value) => {
                const oldValue = obj[prop];
                
                // Solo registrar si realmente cambió
                if (!this.isEqual(oldValue, value)) {
                    // Guardar estado anterior antes del cambio
                    this.saveState(proxyInfo, 'property_change', {
                        property: prop,
                        oldValue: this.deepClone(oldValue),
                        newValue: this.deepClone(value),
                        path: `${objectPath}.${prop}`
                    });

                    // Aplicar el cambio
                    obj[prop] = value;

                    // Notificar cambio
                    this.notifyChange(proxyInfo, prop, oldValue, value);
                }

                return true;
            },

            deleteProperty: (obj, prop) => {
                const oldValue = obj[prop];
                
                // Guardar estado antes de eliminar
                this.saveState(proxyInfo, 'property_deleted', {
                    property: prop,
                    oldValue: this.deepClone(oldValue),
                    path: `${objectPath}.${prop}`
                });

                // Eliminar la propiedad
                const result = delete obj[prop];

                // Notificar cambio
                this.notifyChange(proxyInfo, prop, oldValue, undefined);

                return result;
            }
        });
    }

    /**
     * Crea un Proxy especial para arrays
     * @param {Array} target - Array objetivo
     * @param {Object} proxyInfo - Información del proxy
     * @param {number} depth - Profundidad actual
     * @returns {Proxy} Proxy del array
     */
    createArrayProxy(target, proxyInfo, depth = 0) {
        const { objectPath, options } = proxyInfo;

        return new Proxy(target, {
            get: (obj, prop) => {
                const value = obj[prop];

                // Si es un método de array que modifica
                if (typeof value === 'function' && this.isArrayMutator(prop)) {
                    return (...args) => {
                        // Guardar estado antes de la mutación
                        this.saveState(proxyInfo, 'array_mutation', {
                            method: prop,
                            arguments: args,
                            oldArray: this.deepClone(obj),
                            path: objectPath
                        });

                        // Ejecutar el método
                        const result = value.apply(obj, args);

                        // Notificar cambio
                        this.notifyChange(proxyInfo, prop, null, obj);

                        return result;
                    };
                }

                // Si es un elemento del array y es un objeto
                if (options.trackNested && 
                    depth < options.maxDepth && 
                    value && 
                    typeof value === 'object' && 
                    !Array.isArray(value) &&
                    !(value instanceof Date) && 
                    !(value instanceof RegExp) &&
                    !(value instanceof Error)) {
                    
                    return this.createProxy(value, proxyInfo, depth + 1);
                }

                return value;
            },

            set: (obj, prop, value) => {
                const oldValue = obj[prop];
                
                // Solo registrar si realmente cambió
                if (!this.isEqual(oldValue, value)) {
                    // Guardar estado anterior
                    this.saveState(proxyInfo, 'array_element_change', {
                        index: prop,
                        oldValue: this.deepClone(oldValue),
                        newValue: this.deepClone(value),
                        path: `${objectPath}[${prop}]`
                    });

                    // Aplicar el cambio
                    obj[prop] = value;

                    // Notificar cambio
                    this.notifyChange(proxyInfo, prop, oldValue, value);
                }

                return true;
            }
        });
    }

    /**
     * Verifica si un método de array es mutador
     * @param {string} method - Nombre del método
     * @returns {boolean} True si es mutador
     */
    isArrayMutator(method) {
        const mutators = [
            'push', 'pop', 'shift', 'unshift', 'splice', 
            'reverse', 'sort', 'fill', 'copyWithin'
        ];
        return mutators.includes(method);
    }

    /**
     * Guarda un estado en el historial
     * @param {Object} proxyInfo - Información del proxy
     * @param {string} changeType - Tipo de cambio
     * @param {Object} changeData - Datos del cambio
     */
    saveState(proxyInfo, changeType, changeData = {}) {
        const state = {
            value: this.deepClone(proxyInfo.originalObject),
            timestamp: new Date().toISOString(),
            changeType,
            changeData
        };

        // Agregar al historial
        proxyInfo.states.push(state);

        // Mantener solo los últimos maxStates
        if (proxyInfo.states.length > this.maxStates) {
            proxyInfo.states.shift();
        }
    }

    /**
     * Notifica un cambio
     * @param {Object} proxyInfo - Información del proxy
     * @param {string} property - Propiedad que cambió
     * @param {any} oldValue - Valor anterior
     * @param {any} newValue - Valor nuevo
     */
    notifyChange(proxyInfo, property, oldValue, newValue) {
        if (this.onChangeCallback) {
            try {
                this.onChangeCallback({
                    objectPath: proxyInfo.objectPath,
                    property,
                    oldValue,
                    newValue,
                    timestamp: new Date().toISOString(),
                    states: proxyInfo.states.length
                });
            } catch (error) {
                console.error('SyntropyFront: Error en callback de cambio:', error);
            }
        }
    }

    /**
     * Obtiene el historial de estados de un objeto
     * @param {string} objectPath - Ruta del objeto
     * @returns {Array} Historial de estados
     */
    getObjectHistory(objectPath) {
        const proxyInfo = this.trackedObjects.get(objectPath);
        if (!proxyInfo) {
            console.warn(`SyntropyFront: Objeto no encontrado: ${objectPath}`);
            return [];
        }

        return [...proxyInfo.states];
    }

    /**
     * Obtiene el estado actual de un objeto
     * @param {string} objectPath - Ruta del objeto
     * @returns {Object|null} Estado actual
     */
    getCurrentState(objectPath) {
        const proxyInfo = this.trackedObjects.get(objectPath);
        if (!proxyInfo) {
            return null;
        }

        return {
            value: this.deepClone(proxyInfo.originalObject),
            timestamp: new Date().toISOString(),
            statesCount: proxyInfo.states.length
        };
    }

    /**
     * Obtiene todos los objetos trackeados
     * @returns {Array} Lista de objetos trackeados
     */
    getTrackedObjects() {
        return Array.from(this.trackedObjects.keys());
    }

    /**
     * Remueve un objeto del tracking
     * @param {string} objectPath - Ruta del objeto
     * @returns {Object|null} Objeto original (sin proxy)
     */
    removeObject(objectPath) {
        const proxyInfo = this.trackedObjects.get(objectPath);
        if (!proxyInfo) {
            return null;
        }

        this.trackedObjects.delete(objectPath);
        console.log(`SyntropyFront: Objeto removido del tracking: ${objectPath}`);
        
        return proxyInfo.originalObject;
    }

    /**
     * Limpia todos los objetos trackeados
     */
    clear() {
        this.trackedObjects.clear();
        console.log('SyntropyFront: Todos los objetos removidos del tracking');
    }

    /**
     * Obtiene estadísticas del tracker
     * @returns {Object} Estadísticas
     */
    getStats() {
        const stats = {
            trackedObjects: this.trackedObjects.size,
            totalStates: 0,
            isEnabled: this.isEnabled,
            maxStates: this.maxStates
        };

        for (const proxyInfo of this.trackedObjects.values()) {
            stats.totalStates += proxyInfo.states.length;
        }

        return stats;
    }

    /**
     * Clona profundamente un objeto
     * @param {any} obj - Objeto a clonar
     * @returns {any} Objeto clonado
     */
    deepClone(obj) {
        if (obj === null || obj === undefined) {
            return obj;
        }

        if (typeof obj !== 'object') {
            return obj;
        }

        if (obj instanceof Date) {
            return new Date(obj.getTime());
        }

        if (obj instanceof RegExp) {
            return new RegExp(obj.source, obj.flags);
        }

        if (obj instanceof Error) {
            const error = new Error(obj.message);
            error.name = obj.name;
            error.stack = obj.stack;
            if (obj.cause) {
                error.cause = this.deepClone(obj.cause);
            }
            return error;
        }

        if (Array.isArray(obj)) {
            return obj.map(item => this.deepClone(item));
        }

        const cloned = {};
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                cloned[key] = this.deepClone(obj[key]);
            }
        }

        return cloned;
    }

    /**
     * Compara dos valores para verificar si son iguales
     * @param {any} a - Primer valor
     * @param {any} b - Segundo valor
     * @returns {boolean} True si son iguales
     */
    isEqual(a, b) {
        if (a === b) return true;
        if (a === null || b === null) return a === b;
        if (typeof a !== typeof b) return false;
        if (typeof a !== 'object') return a === b;

        // Para objetos, comparación superficial
        const keysA = Object.keys(a);
        const keysB = Object.keys(b);
        
        if (keysA.length !== keysB.length) return false;
        
        for (const key of keysA) {
            if (!keysB.includes(key)) return false;
            if (a[key] !== b[key]) return false;
        }
        
        return true;
    }
}

// Instancia singleton
const proxyObjectTracker = new ProxyObjectTracker();

var ProxyObjectTracker$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ProxyObjectTracker: ProxyObjectTracker,
    proxyObjectTracker: proxyObjectTracker
});

/**
 * InterceptorRegistry - Registro de interceptores personalizados
 * Permite al usuario inyectar sus propios interceptores sin modificar el código base
 * Usa una Facade para exponer solo métodos seguros a los interceptores
 */
class InterceptorRegistry {
    constructor() {
        this.customInterceptors = new Map();
        this.isInitialized = false;
    }

    /**
     * Crea una API segura para los interceptores
     * Solo expone métodos públicos y seguros
     * @param {Object} config - Configuración con instancias internas
     * @returns {Object} API segura para interceptores
     */
    createInterceptorApi(config) {
        const { breadcrumbStore, agent, contextCollector } = config;
        
        return {
            // Métodos para breadcrumbs
            addBreadcrumb: (category, message, data = {}) => {
                breadcrumbStore.add({ category, message, data, timestamp: new Date().toISOString() });
            },
            
            // Métodos para enviar datos
            sendError: (errorPayload, context = null) => {
                agent.sendError(errorPayload, context);
            },
            
            sendBreadcrumbs: (breadcrumbs) => {
                agent.sendBreadcrumbs(breadcrumbs);
            },
            
            // Métodos para contexto
            getContext: (contextConfig = {}) => {
                return contextCollector.collect(contextConfig);
            },
            
            // Métodos de utilidad
            getTimestamp: () => new Date().toISOString(),
            
            // Información de la API (solo lectura)
            apiVersion: '1.0.0',
            availableMethods: [
                'addBreadcrumb',
                'sendError', 
                'sendBreadcrumbs',
                'getContext',
                'getTimestamp'
            ]
        };
    }

    /**
     * Registra un interceptor personalizado
     * @param {string} name - Nombre del interceptor
     * @param {Object} interceptor - Objeto interceptor con métodos init/destroy
     */
    register(name, interceptor) {
        if (!interceptor || typeof interceptor.init !== 'function') {
            throw new Error(`Interceptor ${name} debe tener un método init()`);
        }

        this.customInterceptors.set(name, {
            name,
            interceptor,
            enabled: true
        });

        console.log(`SyntropyFront: Interceptor personalizado registrado: ${name}`);
    }

    /**
     * Remueve un interceptor personalizado
     * @param {string} name - Nombre del interceptor
     */
    unregister(name) {
        const registered = this.customInterceptors.get(name);
        if (registered) {
            // Destruir el interceptor si está inicializado
            if (this.isInitialized && registered.interceptor.destroy) {
                try {
                    registered.interceptor.destroy();
                } catch (error) {
                    console.warn(`SyntropyFront: Error destruyendo interceptor ${name}:`, error);
                }
            }
            
            this.customInterceptors.delete(name);
            console.log(`SyntropyFront: Interceptor personalizado removido: ${name}`);
        }
    }

    /**
     * Inicializa todos los interceptores personalizados
     * @param {Object} config - Configuración con instancias internas
     */
    init(config = {}) {
        if (this.isInitialized) {
            console.warn('SyntropyFront: InterceptorRegistry ya está inicializado');
            return;
        }

        // Crear API segura para interceptores
        const interceptorApi = this.createInterceptorApi(config);

        for (const [name, registered] of this.customInterceptors) {
            if (registered.enabled) {
                try {
                    // ✅ SEGURO: Pasar solo la API, no el config crudo
                    registered.interceptor.init(interceptorApi);
                    console.log(`SyntropyFront: Interceptor ${name} inicializado`);
                } catch (error) {
                    console.error(`SyntropyFront: Error inicializando interceptor ${name}:`, error);
                }
            }
        }

        this.isInitialized = true;
    }

    /**
     * Destruye todos los interceptores personalizados
     */
    destroy() {
        if (!this.isInitialized) return;

        for (const [name, registered] of this.customInterceptors) {
            if (registered.interceptor.destroy) {
                try {
                    registered.interceptor.destroy();
                    console.log(`SyntropyFront: Interceptor ${name} destruido`);
                } catch (error) {
                    console.warn(`SyntropyFront: Error destruyendo interceptor ${name}:`, error);
                }
            }
        }

        this.isInitialized = false;
    }

    /**
     * Habilita/deshabilita un interceptor personalizado
     * @param {string} name - Nombre del interceptor
     * @param {boolean} enabled - Si está habilitado
     */
    setEnabled(name, enabled) {
        const registered = this.customInterceptors.get(name);
        if (registered) {
            registered.enabled = enabled;
            
            if (this.isInitialized) {
                if (enabled && registered.interceptor.init) {
                    try {
                        // Crear API segura para el interceptor
                        const interceptorApi = this.createInterceptorApi({
                            breadcrumbStore: this.breadcrumbStore,
                            agent: this.agent,
                            contextCollector: this.contextCollector
                        });
                        registered.interceptor.init(interceptorApi);
                        console.log(`SyntropyFront: Interceptor ${name} habilitado`);
                    } catch (error) {
                        console.error(`SyntropyFront: Error habilitando interceptor ${name}:`, error);
                    }
                } else if (!enabled && registered.interceptor.destroy) {
                    try {
                        registered.interceptor.destroy();
                        console.log(`SyntropyFront: Interceptor ${name} deshabilitado`);
                    } catch (error) {
                        console.warn(`SyntropyFront: Error deshabilitando interceptor ${name}:`, error);
                    }
                }
            }
        }
    }

    /**
     * Obtiene la lista de interceptores registrados
     * @returns {Array} Lista de nombres de interceptores
     */
    getRegisteredInterceptors() {
        return Array.from(this.customInterceptors.keys());
    }

    /**
     * Obtiene información de un interceptor específico
     * @param {string} name - Nombre del interceptor
     * @returns {Object|null} Información del interceptor
     */
    getInterceptorInfo(name) {
        const registered = this.customInterceptors.get(name);
        if (registered) {
            return {
                name: registered.name,
                enabled: registered.enabled,
                hasInit: typeof registered.interceptor.init === 'function',
                hasDestroy: typeof registered.interceptor.destroy === 'function'
            };
        }
        return null;
    }

    /**
     * Obtiene la documentación de la API para interceptores
     * @returns {Object} Documentación de la API
     */
    getApiDocumentation() {
        return {
            version: '1.0.0',
            methods: {
                addBreadcrumb: {
                    description: 'Agrega un breadcrumb al historial',
                    signature: 'addBreadcrumb(category, message, data?)',
                    example: 'api.addBreadcrumb("ui", "Usuario hizo click", { element: "button" })'
                },
                sendError: {
                    description: 'Envía un error al backend',
                    signature: 'sendError(errorPayload, context?)',
                    example: 'api.sendError({ message: "Error crítico" }, { device: true })'
                },
                sendBreadcrumbs: {
                    description: 'Envía breadcrumbs al backend',
                    signature: 'sendBreadcrumbs(breadcrumbs)',
                    example: 'api.sendBreadcrumbs([{ category: "ui", message: "Click" }])'
                },
                getContext: {
                    description: 'Obtiene contexto del navegador',
                    signature: 'getContext(contextConfig?)',
                    example: 'api.getContext({ device: true, window: ["url"] })'
                },
                getTimestamp: {
                    description: 'Obtiene timestamp actual en formato ISO',
                    signature: 'getTimestamp()',
                    example: 'const now = api.getTimestamp()'
                }
            }
        };
    }

    /**
     * Limpia todos los interceptores registrados
     */
    clear() {
        this.destroy();
        this.customInterceptors.clear();
    }
}

// Instancia singleton
const interceptorRegistry = new InterceptorRegistry();

var InterceptorRegistry$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    InterceptorRegistry: InterceptorRegistry,
    interceptorRegistry: interceptorRegistry
});

/**
 * WorkerManager - Maneja comunicación con SyntropyWorker
 * Proporciona API para interactuar con el worker desde el main thread
 * 
 * @author SyntropyFront Team
 * @version 1.0.0
 */

class WorkerManager {
    constructor() {
        this.worker = null;
        this.pendingRequests = new Map();
        this.requestId = 0;
        this.isInitialized = false;
        this.config = {};
        
        // Setup worker communication
        this.setupWorker();
    }

    /**
     * Inicializa el worker
     */
    setupWorker() {
        try {
            // Crear worker
            this.worker = new Worker('./src/workers/SyntropyWorker.js');
            
            // Setup message handling
            this.worker.addEventListener('message', (event) => {
                this.handleWorkerMessage(event.data);
            });
            
            // Setup error handling
            this.worker.addEventListener('error', (error) => {
                console.error('SyntropyWorker error:', error);
                this.handleWorkerError(error);
            });
            
            console.log('🔄 WorkerManager: Worker inicializado');
        } catch (error) {
            console.error('WorkerManager: Error inicializando worker:', error);
            this.handleWorkerUnavailable();
        }
    }

    /**
     * Inicializa el worker con configuración
     */
    async init(config) {
        try {
            this.config = config;
            
            const response = await this.sendMessage('INIT', config);
            
            if (response.success) {
                this.isInitialized = true;
                console.log('✅ WorkerManager: Worker inicializado correctamente');
                return true;
            } else {
                throw new Error(response.error || 'Error inicializando worker');
            }
        } catch (error) {
            console.error('WorkerManager: Error en init:', error);
            return false;
        }
    }

    /**
     * Envía mensaje al worker y espera respuesta
     */
    sendMessage(type, payload = {}) {
        return new Promise((resolve, reject) => {
            if (!this.worker) {
                reject(new Error('Worker no disponible'));
                return;
            }

            const id = this.generateRequestId();
            
            // Guardar callback para la respuesta
            this.pendingRequests.set(id, { resolve, reject });
            
            // Enviar mensaje al worker
            this.worker.postMessage({
                type,
                payload,
                id
            });
            
            // Timeout para evitar requests colgados
            setTimeout(() => {
                if (this.pendingRequests.has(id)) {
                    this.pendingRequests.delete(id);
                    reject(new Error(`Timeout en request: ${type}`));
                }
            }, 5000); // 5 segundos timeout
        });
    }

    /**
     * Maneja mensajes del worker
     */
    handleWorkerMessage(data) {
        const { id, success, error, ...response } = data;
        
        const request = this.pendingRequests.get(id);
        if (request) {
            this.pendingRequests.delete(id);
            
            if (success) {
                request.resolve(response);
            } else {
                request.reject(new Error(error || 'Error en worker'));
            }
        } else {
            console.warn('WorkerManager: Respuesta sin request pendiente:', id);
        }
    }

    /**
     * Maneja errores del worker
     */
    handleWorkerError(error) {
        console.error('WorkerManager: Error del worker:', error);
        
        // Limpiar requests pendientes
        this.pendingRequests.forEach((request) => {
            request.reject(new Error('Worker error'));
        });
        this.pendingRequests.clear();
        
        // Fallback a modo sin worker
        this.handleWorkerUnavailable();
    }

    /**
     * Maneja cuando el worker no está disponible
     */
    handleWorkerUnavailable() {
        console.warn('WorkerManager: Worker no disponible, usando fallback');
        
        // Aquí podríamos implementar fallback al modo main thread
        // Por ahora solo loggeamos
    }

    /**
     * Agrega breadcrumb al worker
     */
    async addBreadcrumb(type, message, data = {}) {
        try {
            const response = await this.sendMessage('ADD_BREADCRUMB', {
                type,
                message,
                data
            });
            
            return response;
        } catch (error) {
            console.error('WorkerManager: Error agregando breadcrumb:', error);
            throw error;
        }
    }

    /**
     * Obtiene breadcrumbs del worker
     */
    async getBreadcrumbs() {
        try {
            const response = await this.sendMessage('GET_BREADCRUMBS');
            return response.breadcrumbs || [];
        } catch (error) {
            console.error('WorkerManager: Error obteniendo breadcrumbs:', error);
            return [];
        }
    }

    /**
     * Limpia breadcrumbs del worker
     */
    async clearBreadcrumbs() {
        try {
            const response = await this.sendMessage('CLEAR_BREADCRUMBS');
            return response;
        } catch (error) {
            console.error('WorkerManager: Error limpiando breadcrumbs:', error);
            throw error;
        }
    }

    /**
     * Envía error al worker
     */
    async sendError(error, context = {}) {
        try {
            const response = await this.sendMessage('SEND_ERROR', {
                error,
                context
            });
            
            return response;
        } catch (error) {
            console.error('WorkerManager: Error enviando error:', error);
            throw error;
        }
    }

    /**
     * Actualiza contexto del worker
     */
    async updateContext(context) {
        try {
            const response = await this.sendMessage('UPDATE_CONTEXT', context);
            return response;
        } catch (error) {
            console.error('WorkerManager: Error actualizando contexto:', error);
            throw error;
        }
    }

    /**
     * Ping al worker para verificar conectividad
     */
    async ping() {
        try {
            const response = await this.sendMessage('PING');
            return response;
        } catch (error) {
            console.error('WorkerManager: Error en ping:', error);
            throw error;
        }
    }

    /**
     * Obtiene estadísticas del worker
     */
    async getWorkerStats() {
        try {
            const response = await this.sendMessage('GET_STATS');
            return response;
        } catch (error) {
            console.error('WorkerManager: Error obteniendo stats:', error);
            return null;
        }
    }

    /**
     * Destruye el worker
     */
    destroy() {
        if (this.worker) {
            // Limpiar requests pendientes
            this.pendingRequests.forEach((request) => {
                request.reject(new Error('Worker destroyed'));
            });
            this.pendingRequests.clear();
            
            // Terminar worker
            this.worker.terminate();
            this.worker = null;
            
            console.log('🔄 WorkerManager: Worker destruido');
        }
    }

    /**
     * Genera ID único para requests
     */
    generateRequestId() {
        return `req_${++this.requestId}_${Date.now()}`;
    }

    /**
     * Verifica si el worker está disponible
     */
    isWorkerAvailable() {
        return this.worker !== null && this.isInitialized;
    }

    /**
     * Obtiene estado del worker
     */
    getStatus() {
        return {
            isAvailable: this.isWorkerAvailable(),
            isInitialized: this.isInitialized,
            pendingRequests: this.pendingRequests.size,
            config: this.config
        };
    }
}

var WorkerManager$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: WorkerManager
});

exports.SyntropyFront = SyntropyFront;
exports.agent = agent;
exports.breadcrumbStore = breadcrumbStore;
exports.default = syntropyFront;
exports.interceptors = interceptors;
//# sourceMappingURL=index.cjs.map
